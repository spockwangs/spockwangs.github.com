<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/stylesheets/base.css" />
    <link rel="stylesheet" href="/stylesheets/screen.css" media="screen" />
    <title>生成可执行的共享库</title>
  </head>
  <body>
    <header id="header">
      <h1 id="title"><a href="/">Judewang's Thoughts</a></h1>
    </header>

    <nav id="nav">
      <ul id="menus-wrap">
        <li class="menu first"><a href="/">Archives</a></li>
        <li class="menu"><a href="/about.html">About</a></li>
      </ul>
    </nav>

    <div id="main" class="col-wrapper">
      <div id="content-wrapper" class="col-3-4">
        <div id="content">
          <article class="article">
  <header>
    <h1 class="title">生成可执行的共享库</h1>
    <div class="meta">
      
      <span class="thetag"><a href="/tags/Programming" title='Posts tagged"Programming"'>Programming</a></span>
      
      <span class="meta-date">2012-02-02</span>
    </div>
  </header>
  <div id="toc-wrapper" class="invisible">
    <div class="toc-header">Table of Contents</div>
    <div id="toc">
    </div>
  </div>
  <div id="article-content" class="content">
    <p>
	Linux系统下共享对象文件和可执行文件的格式都是ELF格式，它们并没有什么本质  上的区别。共享对象文件也是可以执行的。例如Linux下动态链接器ld-linux.so就  是共享对象文件，它也可以像可执行文件一样执行；Glibc库函数也是一样。
</p>
<p>
	共享对象文件要执行有2个问题要解决：
</p>
<ol>
	<li>
		共享对象文件的<strong>加载地址(loading address)</strong>是随机的（由操作系统决定恰当的地址），不像可执行文件，每次都加载到相同的固定地址（在Linux下是0x8048000）。因此，共享对象要能正确执行，必须编译成<strong>位置无关代码（Position Independent Code, PIC）</strong>。这可以通过gcc的-fpic选项得到。
	</li>
	<li>
		共享对象也会用到其他的共享库函数（如C语言库函数），引用的外部符号都必须被<strong>解析和重定位</strong>，而这些必须在运行时完成。这就需要动态链接器的帮助。所以，共享对象必须编译成依赖动态链接器，也就是说共享对象文件要有<strong>.interp段</strong>。若没有这个段，操作系统在执行时会认为这个文件不需要动态链接器的支持，因而会直接执行这个文件，最后由于对外部符号的访问是错误的（对外部符号的引用没有正确定位）导致segmentation fault。通常情况下，共享对象文件编译时是不会生成.interp段的，只有可执行文件在使用了共享库的情况下才会生成这个段。下面我就来讲讲如何在共享对象文件中生成这个段。
	</li>
</ol>
<p>
	最好用一个简单的例子来讲解这2个问题如何解决。示例代码如下：
</p>
<pre class="borderindent">#include &lt;stdio.h&gt; // for printf()
#include  &lt;stdlib.h&gt;  // for exit()
void fun()
{
    printf(&quot;This is fun./n&quot;);
    exit(0);
}</pre>
<p>
	该代码保存在<em>fun.c</em>文件中。
</p>
<p>
	&nbsp;
</p>
<p>
	第一个问题容易解决。要编译成PIC代码，只需要传递<em>gcc</em>选项<em>-fpic</em>即可：
</p>
<pre class="borderindent">$ <kbd>gcc -fpic -shared -Wl,-e,fun -o fun.so fun.c</kbd></pre>
<p>
	其中<tt>-Wl,-e,fun</tt>是通知链接器生成的对象文件的入口地址是<code>fun</code>。执行文件<em>fun.so</em>会得到如下结果：
</p>
<pre class="borderindent">$ <kbd>./fun.so</kbd>
<samp>Segmentation fault (core dumped)</samp></pre>
<p>
	之所以这样是因为在<em>fun.c</em>中调用了C语言库函数<code>printf()</code>，但没有对这个外部符号正确地重定位（由于没有.interp段，操作系统认为这个文件不需要动态链接库重定位），因而引用了非法地址，所以产生了段错误。通过下面的命令可以查看<em>fun.so</em>文件没有.interp段。
</p>
<pre class="borderindent">$ <kbd>readelf -l ./fun.so | grep interp</kbd>
$</pre>
<p>
	结果没有输出，说明<em>fun.so</em>文件中确实不存在.interp段。
</p>
<p>
	&nbsp;
</p>
<p>
	要生成.interp段，可以在某个源文件中加入下面一句：
</p>
<pre class="borderindent">const char __invoke_dynamic_linker__[] __attribute__ ((section (&quot;.interp&quot;))) 
    = RUNTIME_LINKER;</pre>
<p>
	这正是<em>glibc</em>的做法。这句代码在<em>glibc</em>的<em>elf/interp.c</em>文件中。    这也是为什么<em>glibc</em>库函数有.interp段的原因。RUNTIME_LINKER就是动态链接库的名字，取决于目标机器。我们也可以用这种方式来解决这个问题，代码如下：
</p>
<pre class="borderindent">#include &lt;stdio.h&gt;    // for printf()
#include &lt;stdlib.h&gt;   // for exit()
const char __invoke_dynamic_linker[] __attribute__ ((section (&quot;.interp&quot;))) 
    = &quot;/lib/ld-linux.so.2&quot;;
void fun()
{
    printf(&quot;This is fun./n&quot;);
    exit(0);
}</pre>
<p>
	注意我用<q>/lib/ld-linux.so.2</q>替代了RUNTIME_LINKER，因为它就是linux上的动态链接器，在<em>/lib</em>目录下。
</p>
<p>
	&nbsp;
</p>
<p>
	用如下方式编译并执行：
</p>
<pre class="borderindent">$ <kbd>gcc -fpic -shared -o fun.so -Wl,-e,fun fun.c</kbd>
$ <kbd>./fun.so</kbd></pre>
<p>
	终于大功告成。
</p>
<h3>
	参考文献
</h3>
<p>
	本文方法来  自<a href="http://sourceware.org/ml/binutils/2008-06/msg00161.html" target="_blank">这个帖子的回帖</a>。
</p>
<hr />
<p>
	<em>Updated: 2011-03-04 17:48</em>
</p>

  </div>
  <footer class="footer">
    
    <div class="previous">
      <a href="/2012/02/02/%25e6%25af%2594%25e7%2589%25b9%25e6%2593%258d%25e7%25ba%25b5%25e6%258a%2580%25e5%25b7%25a7.html" title="Previous post: 比特操纵技巧">«比特操纵技巧</a>
    </div>
    
    
    <div class="next">
      <a href="/2012/02/02/%25e9%2585%258d%25e7%25bd%25aesubversion.html" title="Next post: 配置Subversion">配置Subversion»</a>
    </div>
    
  </footer>
</article>

        </div>
      </div>
      <div id="sidebar" class="col-1-4">
        <div class="tag-wrapper">
          <h1>Tags</h1>
          <ul class="tag-list">
            
            <li class="tag-item"><span class="thetag"><a href="/tags/Programming/" title='Posts tagged "Programming"'>Programming</a></span>&nbsp;x&nbsp;19</li>
            
            <li class="tag-item"><span class="thetag"><a href="/tags/名言警句/" title='Posts tagged "名言警句"'>名言警句</a></span>&nbsp;x&nbsp;1</li>
            
            <li class="tag-item"><span class="thetag"><a href="/tags/Administration/" title='Posts tagged "Administration"'>Administration</a></span>&nbsp;x&nbsp;5</li>
            
            <li class="tag-item"><span class="thetag"><a href="/tags/Network/" title='Posts tagged "Network"'>Network</a></span>&nbsp;x&nbsp;3</li>
            
          </ul>
        </div>
      </div>
    </div>

    <footer id="footer">
      <p class="copyright">Copyright&nbsp;&copy;&nbsp2013 - judewang - Powered by jekyll</p>
    </footer>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="/javascripts/generate_toc.js"></script>
    <script src="//google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
    <script type="text/javascript">
      <!-- Add Google prettify support. -->
      $(function () {
          $("pre > code").addClass("prettyprint");
      });
      </script>
    </div>
  </body>
</html>
