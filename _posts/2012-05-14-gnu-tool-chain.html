---
layout: post
title: GNU Tool Chain
tags:
- Programming
status: publish
type: post
published: true
meta:
  _edit_lock: '1336924920'
  _edit_last: '1'
  _pingme: '1'
  _encloseme: '1'
---
<h2>Create Static Libraries</h2>
<ol>
<li>Compile source files<br />
<code>$ gcc -c file1.c file2.c ...</code></li>
<li>Create archives<br />
<code>$ ar r lib<sth>.a file1.o file2.o ...</code></li>
</ol>
<p>See ar(1).</p>
<h2>Link with Static Libraries</h2>
<code>$ gcc -static -o outputfile file1.c file2.c -L<search path> -l<archive name></code>
<p>
Use option -static to avoid linking against shared libraries.  Use option -l to specify which libraries are required and -L to specify where to find these libraries.  If the required libraries are in system paths (i.e. /lib and /usr/lib) -L is not required because the linker will search the system path by default.  The paths specified on command line are searched before system paths.  See ld(1). </p>
<h2>How Linkers Use Static Libraries to Resolve References</h2>
<p>
See Section 7.6.3 of Computer Systems: A Programmer's Perspective.
</p>
<p>
Watch out for mutual dependences and cyclic dependences of the static libraries.  See option --start-group of ld(1).
</p>
<h2>Create Shared Libraries</h2>
<code>$ gcc -shared -fpic -o lib&lt;st&gt;.so file1.c file2.c ... dependent_shared_libraries</code>
<p>
The dependent shared libraries will be stored in the .dynamic section (its type is "DT_NEED" and its value is whatever you put on the command line (absolute or relative path), you can check it using "readelf -d") of the generated shared object.  It tells the dynamic linker which libraries are needed by this shared object.
</p>
<h2>Link with shared libraries</h2>
<code>$ gcc -o outputfile file1.c file2.c ... -L&lt;search path&gt; -l&lt;library name&gt; ... -Wl,-rpath,&lt;path&gt; ...</code>
<p>
Like linking with static objects, when linking with shared objects the
linker needs to know which objects are required and where to find them.  It
uses the same mechanisms as linking with static objects to specify these
info.  See above "Link with Static Libraries".
</p>
<p>
If the shared objects on the command line require other shared objects (you can check this by see the entry type "DT_NEED" of .dynamic section), the linker editor needs to know where to find the required shared objects.  This info can be specified with the option <code>"-rpath-link"</code> or <code>"-rpath"</code> of ld or by other ways.  See ld(1) about options <code>"-rpath-link"</code> and <code>"-rpath"</code>.
</p>
<p>
For example:
<pre>
$ gcc main.c -L. -lfun -Wl,-rpath,pos
</pre>
where main.c depends libfun.so which depends on some shared objects resides in "pos".  Option "-Wl," is a way for gcc to pass options to ld.
</p>
<p>
There are other ways to specify the link-time shared objects search path other than the above ways and they are searched in the following order:
<ol>
<li>-rpath-link</li>
<li>-rpath</li>
<li>Environment variable LD_LIBRARY_PATH.</li>
<li>system paths /lib and /usr/lib.</li>
<li>the directories specified in /etc/ld.so.conf</li>
</ol>
</p>
<p>
This is incomplete.  See option <code>-rpath-link</code> of ld(1) for more details.
</p>
<h2>Runtime shared objects search path</h2>
<p>
When a executive which depends on some shared objects runs the dynamic linker needs to load those shared objects.  So it needs to know two things: which shared objects and where to find them.  
</p>
<p>
The required shared objects are stored in the DT_NEED entry (shown as "(NEEDED)" in output of "readelf -d", may not exist if it does not depend on anything) of .dynamic section in the object, which is specified on the command line when generating this object file.</p>
<p>
If the value of DT_NEED entry is a path (absolute or relative) the dynamic linker will try to find it there, and if it does not find it the executable can not run.  If it is just a file name the dynamic linker will search for it in a series of directories in the following order:
<ol>
<li>The directories (separated by colons) in the entry DT_RPATH of .dynamic section in the executable (these paths are specified by the option "-rpath" of ld or "-Wl,-rpath" of gcc);</li>
<li>The directories in the environment variable LD_LIBRARY_PATH (separated by colons);</li>
<li>the directories specified in /etc/ld.so.conf (actually /etc/ld.so.cache, so if you edit /etc/ld.so.conf you should run "ldconfig" to update the cache and the shared objects should be named like libxxx.so);</li>
<li>/lib</li>
<li>/usr/lib</li>
</ol>
</p>
<p>
You can see the searching process by setting the environment variable LD_DEBUG to "libs" when running the executable.  See ld.so(1).
</p>
<h2>Loading of dependent shared objects and symbol resolving</h2>
<p>
Often the executive depends on some shared objects, which depends on some other objects, which depends on some others, and so on.  So the depend relation is like a graph with the executive being the root.  The Linux dynamic linker is responsible for loading the dependent shared objects and loads them in breadth first search (BFS) order.  The dynamic liner has a global symbol table which includes all symbols it knows so far.  The global symbol table is used to resolve symbols in the executive when running.  It merges the symbol table of the shared object with global symbol table when loaded.  If the symbol table has some symbol with the same name as a symbol in the global symbol table, it will be ignored.  This will lead to global symbol interposition.  So if we want to avoid this problem we must make sure the global variables and functions in our programs have unique names. 
</p>
<p>
The phase of symbol resolving begins after all dependent shared objects are loaded and global symbol table is constructed.
</p>
<p>
The procedure of loading and symbol resolving can be checked using the env variable LD_DEBUG.  See ld.so(8).
</p>
<h2>References</h2>
<ol>
<li>ld(1) options -shared, -L, -l, -rpath, -rpath-link</li>
<li>ld.so(1)</li>
<li>gcc(1) options -shared, -static, and -Wl,</li>
<li>程序员的自我修养，Sections 7.6, 8.4 and 8.5</li>
<li>Computer System: A Programmer's Perspective, Chapter 7.</li>
</ol>
